data TimerId(Number)

fun unTimerId(TimerId(t)) {
    t
}

let COMPILE_DELAY = 1000 // milliseconds

forall { a } fun as_bool(a: a): Boolean {
    let to_bool = _unsafe_js("function (x) { return !!x; }");
    to_bool(_unsafe_coerce(a))
}

fun querySelector(sel) {
    _unsafe_js("document").querySelector(sel)
}

fun getElementById(id) {
    _unsafe_js("document").getElementById(id)
}

fun setTimeout(f, delay): TimerId {
    TimerId(_unsafe_js("window").setTimeout(f, delay))
}

fun clearTimeout(tid: TimerId) {
    _unsafe_js("window").clearTimeout(unTimerId(tid))
}

fun compileCrux(source): Result String String {
    let rawRes = _unsafe_js("window").compileCrux(source)
    if as_bool(rawRes.error) {
        Err(rawRes.error)
    } else {
        Ok(rawRes.result)
    }
}

fun newXmlHttpRequest(): XHR {
    _unsafe_js("new XMLHttpRequest")
}

fun toJson(o): String {
    _unsafe_js("JSON.stringify")(o)
}

fun parseJson(s) {
    _unsafe_js("JSON.parse")(s)
}

type XHR = {
    open: (String, String) -> (),
    setRequestHeader: (String, String) -> (),
    abort: () -> (),
    send: (String) -> (),
    onload: () -> (),
    onerror: (String) -> (),
    ontimeout: () -> (),
    response: String,
    mutable timeout: Number,
}

data CompilerState {
    Idle,
    Waiting(TimerId),
    Optimizing(XHR),
}

data LastCompile(String, Boolean)

data Compiler({
    onresult: (Result String String) -> (),
    mutable state: CompilerState,
    mutable lastCompile: Option LastCompile,
})

fun newCompiler(onresult) {
    return Compiler({
        onresult: onresult,
        state: Idle,
        lastCompile: None,
    })
}

fun compile(Compiler(this), source, optimize) {
    match this.state {
        Idle => {
        }
        Waiting(tid) => {
            clearTimeout(tid)
        }
        Optimizing(xhr) => {
            xhr.abort()
        }
    }

    this.state = Idle

    if this.lastCompile->eq(Some(LastCompile(source, optimize))) {
        return ()
    }

    this.state = Waiting(setTimeout(fun() {
        // TODO: set timer to null

        let result = match compileCrux(source) {
            Err(error) => {
                this.state = Idle;
                this.lastCompile = Some(LastCompile(source, optimize))
                this.onresult(Err("Compile error:\n" + error))
                return ()
            }
            Ok(res) => {
                if not(optimize) {
                    this.state = Idle;
                    this.lastCompile = Some(LastCompile(source, optimize))
                    this.onresult(Ok(res))
                    return ()
                } else {
                    res
                }
            }
        }

        let xhr = newXmlHttpRequest()
        xhr.open("POST", "https://crux-closure-service.herokuapp.com/compile")
        xhr.setRequestHeader("content-type", "application/json")
        xhr.timeout = 60000 // 60s
        xhr.send(toJson({source: result}))
        this.state = Optimizing(xhr)

        xhr.onload = fun() {
            // TODO: allow this kind of shadowing
            let result2 = parseJson(xhr.response)
            this.state = Idle
            this.lastCompile = Some(LastCompile(source, optimize))
            this.onresult(Ok(result2.source))
        }

        xhr.onerror = fun(e) {
            this.lastCompile = None
            this.onresult(Err("Network error:\n" + e))
        }

        xhr.ontimeout = fun() {
            this.lastCompile = None
            this.onresult(Err("Network timeout"))
        }
    }, COMPILE_DELAY))
}

fun main() {
    let sourceTextArea = querySelector(".crux-playground .source")
    let outputTextArea = querySelector(".crux-playground .output")
    let optimizeCheckbox = querySelector(".crux-playground .optimize")
    let runButton = querySelector(".crux-playground .run")

    let loadExampleSource = fun() {
        let mutable source: String = getElementById("initial_example").text
        source = source->trim()
        sourceTextArea.value = source
    }

    let compiler = newCompiler(fun(result) {
        match result {
            Ok(res) => {
                outputTextArea.classList.remove("has-errors")
                outputTextArea.value = res
            }
            Err(err) => {
                outputTextArea.classList.add("has-errors")
                outputTextArea.value = err
            }
        }
    })

    let recompile = fun() {
        let content = sourceTextArea.value
        let optimize = optimizeCheckbox.checked
        compiler->compile(content, optimize)
    }

    let registerCompileListener = fun() {
        sourceTextArea.addEventListener("input", recompile)
        optimizeCheckbox.addEventListener("change", recompile)
    }

    loadExampleSource()
    registerCompileListener()
    recompile()

    sourceTextArea.disabled = False
    sourceTextArea.setSelectionRange(0, 0)
    sourceTextArea.focus()

    runButton.addEventListener("click", fun() {
        print("run button temporarily disabled")
    })
}

let _ = main()
