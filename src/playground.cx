data TimerId(Number)

fun unTimerId(TimerId(t)) {
    t
}

let COMPILE_DELAY = 1000 // milliseconds

forall { a } fun as_bool(a: a): Boolean {
    let to_bool = _unsafe_js("function (x) { return !!x; }");
    to_bool(_unsafe_coerce(a))
}

fun querySelector(sel) {
    _unsafe_js("document").querySelector(sel)
}

fun getElementById(id) {
    _unsafe_js("document").getElementById(id)
}

fun setTimeout(f, delay): TimerId {
    TimerId(_unsafe_js("window").setTimeout(f, delay))
}

fun clearTimeout(tid: TimerId) {
    _unsafe_js("window").clearTimeout(unTimerId(tid))
}

fun compileCrux(source): Result String String {
    let rawRes = _unsafe_js("window").compileCrux(source)
    if as_bool(rawRes.error) {
        Err(rawRes.error)
    } else {
        Ok(rawRes.result)
    }
}

fun newXmlHttpRequest(): XHR {
    _unsafe_js("new XMLHttpRequest")
}

fun toJson(o): String {
    _unsafe_js("JSON.stringify")(o)
}

fun parseJson(s) {
    _unsafe_js("JSON.parse")(s)
}

type XHR = {
    open: (String, String) -> (),
    setRequestHeader: (String, String) -> (),
    abort: () -> (),
    send: (String) -> (),
    onload: () -> (),
    onerror: (String) -> (),
    ontimeout: () -> (),
    response: String,
    mutable timeout: Number,
}

data CompilerState {
}

data Compiler {
    Compiler({
        onresult: (Result String String) -> (),
        mutable lastCompiledOptimize: Boolean,
        mutable xhr: Option XHR,
        mutable lastCompiledSource: Option String,
        mutable timerId: Option TimerId,
    })
}

fun newCompiler(onresult): Compiler {
    return Compiler({
        onresult: onresult,
        lastCompiledSource: None,
        lastCompiledOptimize: False,

        timerId: None,
        xhr: None
    })
}

fun compile(compiler: Compiler, source: String, optimize) {
    let Compiler(this) = compiler
    match this.timerId {
        Some(tid) => {
            clearTimeout(tid)
        }
        None => {}
    }

    match this.xhr {
        Some(x) => {
            x.abort()
            this.xhr = None
        }
        None => {}
    }

    match this.lastCompiledSource {
        Some(lcs) => {
            if lcs == source && optimize == this.lastCompiledOptimize {
                return ()
            }
        }
        _ => {
        }
    }

    this.timerId = Some(setTimeout(
        fun() {
            this.timerId = None

            let result = match compileCrux(source) {
                Err(error) => {
                    this.lastCompiledSource = Some(source)
                    this.onresult(Err("Compile error:\n" + error))
                    return ()
                }
                Ok(res) => {
                    if not(optimize) {
                        this.lastCompiledSource = Some(source)
                        this.onresult(Ok(res))
                        return ()
                    } else {
                        res
                    }
                }
            }

            let xhr = newXmlHttpRequest()
            this.xhr = Some(xhr)
            xhr.open("POST", "https://crux-closure-service.herokuapp.com/compile")
            xhr.setRequestHeader("content-type", "application/json")
            xhr.timeout = 15000 // 15s
            xhr.send(toJson({source: result}))

            xhr.onload = fun() {
                // TODO: allow this kind of shadowing
                let result2 = parseJson(xhr.response)
                this.xhr = None
                this.lastCompiledSource = Some(source)
                this.onresult(Ok(result2.source))
            }

            xhr.onerror = fun(e) {
                this.xhr = None
                this.lastCompiledSource = None
                this.onresult(Err("Network error:\n" + e))
            }

            xhr.ontimeout = fun() {
                this.xhr = None
                this.lastCompiledSource = None
                this.onresult(Err("Network timeout"))
            }
        }, COMPILE_DELAY
    ))
}

fun main() {
    let sourceTextArea = querySelector(".crux-playground .source")
    let outputTextArea = querySelector(".crux-playground .output")
    let optimizeCheckbox = querySelector(".crux-playground .optimize")
    let runButton = querySelector(".crux-playground .run")

    let loadExampleSource = fun() {
        let source = getElementById("initial_example").text
        // source = source.replace(/^\s+/, "") // trim leading whitespace
        sourceTextArea.value = source
    }

    let compiler = newCompiler(
        fun (result) {
            match result {
                Ok(res) => {
                    outputTextArea.classList.remove("has-errors")
                    outputTextArea.value = res
                }
                Err(err) => {
                    outputTextArea.classList.add("has-errors")
                    outputTextArea.value = err
                }
            }
        }
    )

    let recompile = fun() {
        let content = sourceTextArea.value
        let optimize = optimizeCheckbox.checked
        compiler->compile(content, optimize)
    }

    let registerCompileListener = fun() {
        sourceTextArea.addEventListener("input", recompile)
        optimizeCheckbox.addEventListener("change", recompile)
    }

    loadExampleSource()
    registerCompileListener()
    recompile()

    sourceTextArea.disabled = False
    sourceTextArea.setSelectionRange(0, 0)
    sourceTextArea.focus()

    runButton.addEventListener("click", fun() {
        print("run button temporarily disabled")
    })
}

let _ = main()
