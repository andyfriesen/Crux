
data Error {
    Error(String)
}

export data JsonValue {}

let _typeOf: (JsonValue) -> String = _unsafe_js("function (x) { return typeof x; }")
let _throw: (Error) -> anyOther = _unsafe_js("function (e) { throw e; }")
let _isNull: (JsonValue) -> Boolean = _unsafe_js("function (o) { return o === null; }")
let _getAttr: (JsonValue, String) -> any2 = _unsafe_js("function (o, k) { return o[k]; }")
let _parseJson: (String) -> JsonValue = _unsafe_js("function (s) { return JSON.parse(s); }")

let _isArray = _unsafe_js("function (a) { return Array.isArray(a); }")

let _stringify = _unsafe_js("function (o) { return JSON.stringify(o); }")

fun assert(b: Boolean, error: String) {
    if b {} else {
        _throw(Error(error))
    }
}

fun assertTypeOf(a: JsonValue, expectedType: String) {
    let t = _typeOf(a);
    if expectedType != t {
        _throw(Error("Wanted " + expectedType + " but got " + t + ": " + _stringify(a)))
    }
}

export fun decodeNumber(a: JsonValue): Number {
    assertTypeOf(a, "number")
    return _unsafe_coerce(a)
}

export fun decodeBoolean(a: JsonValue): Boolean {
    assertTypeOf(a, "boolean")
    return _unsafe_coerce(a)
}

export fun decodeString(a: JsonValue): String {
    assertTypeOf(a, "string")
    return _unsafe_coerce(a)
}

export fun decodeNullable(decoder: (JsonValue) -> any): (JsonValue) -> Option any {
    fun(a) {
        if (_isNull(a)) {
            return None
        } else {
            return Some(decoder(a))
        }
    }
}

export fun decodeArray(
    elementDecoder: (JsonValue) -> element
): (JsonValue) -> Array element {
    fun (arr) {
        assert(_isArray(arr), "Expected array but got " + _stringify(arr))

        let mutable result = [];
        for element in _unsafe_coerce(arr) {
            result->append(elementDecoder(element))
        }
        return result
    }
}

export fun decodeKey(
    keyDecoder: (JsonValue) -> element,
    obj: JsonValue,
    key: String
): element {
    assertTypeOf(obj, "object")
    return keyDecoder(_getAttr(obj, key))
}

export fun fromString(s: String, decoder: (JsonValue) -> any): any {
    decoder(_parseJson(s))
}

// Encoder

// Crux needs tuples.
export data ObjectMember {
    ObjectMember(String, JsonValue)
}

let setProperty = _unsafe_js("function(o, k, v) { o[k] = v; }")

export fun encodeObject(members: Array ObjectMember): JsonValue {
    let v = _unsafe_js("{}")

    // TODO: need irrefutable pattern matches in iteration
    for member in members {
        match member {
            ObjectMember(key, value) => setProperty(v, key, value);
        }
    }

    return _unsafe_coerce(v)
}

export fun encodeArray(v: Array JsonValue): JsonValue {
    // we know that the crux representation of arrays lines up with javascript
    return _unsafe_coerce(v)
}

export fun encodeString(v: String): JsonValue {
    return _unsafe_coerce(v)
}

export let nullJSValue: JsonValue = _unsafe_js("null")

export fun encodeNullable(encode : (a) -> JsonValue, o : Option a) : JsonValue {
    match o {
        None        => nullJSValue;
        Some(value) => encode(value);
    }
}

fun encodeNumber(v: Number): JsonValue {
    return _unsafe_coerce(v)
}

fun encodeBoolean(v: Boolean): JsonValue {
    return _unsafe_coerce(v)
}


export let renderJSON: (JsonValue) -> String = _unsafe_js("JSON.stringify")
