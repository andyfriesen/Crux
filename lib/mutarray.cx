pragma { NoBuiltin }

import {
    array
    string
}

export data MutableArray a {}

let _unsafe_new: fun(Number) -> mutable [a] =
    _unsafe_js("function (len) { return new Array(len); }")

let _unsafe_set = _unsafe_js("function (arr, idx, el) { arr[idx] = el; }")
let _unsafe_get = _unsafe_js("function (arr, idx) { return arr[idx]; }")

export forall {a} fun append(a: mutable [a], v: a): () {
    _unsafe_coerce(a).push(v)
}

export forall {a} fun get(a: mutable [a], idx: Number) {
    _unsafe_get(a, idx)
}

export forall {a} fun len(a: mutable [a]): Number {
    _unsafe_coerce(a).length
}

export forall {a} fun replicate(element: a, length: Number): mutable [a] {
    let arr = _unsafe_new(length);

    let mutable i = 0;
    while i < length {
        _unsafe_set(arr, i, element)
        i = i + 1
    };

    arr
}

export forall {a, b} fun each(arr: mutable [a], f: fun(a) -> b): () {
    let mutable i = 0
    let length = len(arr)
    while i < length {
        f(_unsafe_get(arr, i))
        i = i + 1
    }
}

export forall {a} fun sliceFrom(arr: mutable [a], start: Number): mutable [a] {
    _unsafe_coerce(arr).slice(start)
}

export forall {a} fun sliceTo(arr: mutable [a], end: Number): mutable [a] {
    _unsafe_coerce(arr).slice(0, end)
}

export forall {a} fun slice(arr: mutable [a], start: Number, end: Number): mutable [a] {
    _unsafe_coerce(arr).slice(start, end)
}

export forall{a} fun freeze(arr: mutable [a]): [a] {
    _unsafe_coerce(arr).slice()
}

// TODO: add comparator support
export fun sort(arr: mutable [string.String]) {
    _unsafe_coerce(arr).sort()
}
